-- ========================================
-- 1. Aggregate Functions
-- ========================================

-- Counting rows
SELECT COUNT(*) AS total_employees FROM employees;
SELECT COUNT(email) AS employees_with_email FROM employees;
SELECT COUNT(DISTINCT department) AS unique_departments FROM employees;

-- Sum, Average, Max, Min
SELECT SUM(salary) AS total_salaries FROM employees;
SELECT AVG(salary) AS average_salary FROM employees;
SELECT MAX(salary) AS highest_salary, MIN(salary) AS lowest_salary FROM employees;

-- String and Array aggregation
SELECT department, STRING_AGG(first_name, ', ') AS employee_names
FROM employees
GROUP BY department;

SELECT department, ARRAY_AGG(salary) AS salary_array
FROM employees
GROUP BY department;

-- Statistical functions
SELECT department, STDDEV(salary) AS salary_std_dev, VARIANCE(salary) AS salary_variance
FROM employees
GROUP BY department;

-- GROUP BY examples
SELECT department, COUNT(*) AS employee_count, SUM(salary) AS total_salary, AVG(salary) AS avg_salary
FROM employees
GROUP BY department;

-- HAVING clause
SELECT department, COUNT(*) AS employee_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 5;

-- Window functions
SELECT employee_id, first_name, department, salary,
       AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary
FROM employees;

-- Handling NULLs
SELECT COUNT(*) AS total_rows, COUNT(email) AS non_null_emails, COUNT(*) - COUNT(email) AS null_emails
FROM employees;

-- ========================================
-- 2. Joining Tables
-- ========================================

-- INNER JOIN
SELECT c.name, c.email, o.order_date, o.total_amount
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id;

-- LEFT JOIN
SELECT c.name, c.email, o.order_date, o.total_amount
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id;

-- RIGHT JOIN
SELECT c.name, c.email, o.order_date, o.total_amount
FROM customers c
RIGHT JOIN orders o ON c.customer_id = o.customer_id;

-- FULL OUTER JOIN
SELECT c.name, c.email, o.order_date, o.total_amount
FROM customers c
FULL OUTER JOIN orders o ON c.customer_id = o.customer_id;

-- CROSS JOIN
SELECT c.name, p.product_name
FROM customers c
CROSS JOIN products p;

-- Multiple table join
SELECT c.name, o.order_date, oi.quantity, p.product_name, p.price
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_items oi ON o.order_id = oi.order_id
INNER JOIN products p ON oi.product_id = p.product_id;

-- Self join
SELECT e1.name AS employee, e2.name AS manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.employee_id;

-- Join with condition
SELECT c.name, o.order_date, o.total_amount
FROM customers c
INNER JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= '2024-01-01' AND o.total_amount > 100;

-- ========================================
-- 3. Advanced Querying
-- ========================================

-- Subquery
SELECT first_name, last_name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- Common Table Expression (CTE)
WITH regional_sales AS (
    SELECT region_id, SUM(amount) AS total_sales
    FROM orders
    GROUP BY region_id
)
SELECT region_id, total_sales
FROM regional_sales
WHERE total_sales > 1000000;

-- Recursive CTE
WITH RECURSIVE org_chart AS (
    SELECT employee_id, first_name, last_name, manager_id
    FROM employees
    WHERE manager_id IS NULL
    UNION ALL
    SELECT e.employee_id, e.first_name, e.last_name, e.manager_id
    FROM employees e
    INNER JOIN org_chart oc ON e.manager_id = oc.employee_id
)
SELECT * FROM org_chart;

-- Set operations
SELECT product_name FROM warehouse_1
UNION
SELECT product_name FROM warehouse_2;

SELECT product_id FROM warehouse_1 WHERE quantity = 0
INTERSECT
SELECT product_id FROM warehouse_2 WHERE quantity = 0;

-- Window function example
SELECT first_name, last_name, department, salary,
       RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_salary_rank
FROM employees;

-- Pivot (Conditional Aggregation)
SELECT product_name,
       SUM(CASE WHEN year = 2022 THEN sales_amount ELSE 0 END) AS year_2022,
       SUM(CASE WHEN year = 2023 THEN sales_amount ELSE 0 END) AS year_2023,
       SUM(CASE WHEN year = 2024 THEN sales_amount ELSE 0 END) AS year_2024
FROM sales
GROUP BY product_name;

-- Unpivot
SELECT product_name, '2022' AS year, year_2022 AS sales_amount FROM pivoted_sales
UNION ALL
SELECT product_name, '2023' AS year, year_2023 AS sales_amount FROM pivoted_sales
UNION ALL
SELECT product_name, '2024' AS year, year_2024 AS sales_amount FROM pivoted_sales
ORDER BY product_name, year;

-- Complex filtering
SELECT employee_id,
       SUM(salary) OVER (PARTITION BY department) AS total_dept_salary,
       AVG(salary) FILTER (WHERE tenure > 5) OVER () AS avg_salary_senior
FROM employees;

-- Custom sorting
SELECT product_name, status
FROM orders
ORDER BY CASE status
           WHEN 'High Priority' THEN 1
           WHEN 'Medium Priority' THEN 2
           WHEN 'Low Priority' THEN 3
           ELSE 4
         END;

-- ========================================
-- 4. Transactions & ACID Properties
-- ========================================

-- Simple transaction
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
COMMIT;

-- Transaction with rollback
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
ROLLBACK;

-- Atomicity example
BEGIN;
INSERT INTO orders (customer_id, total) VALUES (1, 250.00);
INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 101, 2);
UPDATE inventory SET stock = stock - 2 WHERE product_id = 101;
COMMIT;

-- Consistency example
BEGIN;
INSERT INTO customers (name, email) VALUES ('John Doe', 'john@email.com');
INSERT INTO orders (customer_id, total) VALUES (LASTVAL(), 100.00);
COMMIT;

-- Isolation levels
BEGIN TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
COMMIT;

BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
COMMIT;

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
COMMIT;

BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
COMMIT;

SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- Savepoints
BEGIN;
INSERT INTO customers (name, email) VALUES ('Alice', 'alice@email.com');
SAVEPOINT after_customer_insert;
INSERT INTO orders (customer_id, total) VALUES (1, 500.00);
ROLLBACK TO SAVEPOINT after_customer_insert;
INSERT INTO orders (customer_id, total) VALUES (1, 300.00);
COMMIT;

-- Multiple savepoints
BEGIN;
INSERT INTO products (name, price) VALUES ('Laptop', 999.99);
SAVEPOINT sp1;
INSERT INTO products (name, price) VALUES ('Mouse', 25.99);
SAVEPOINT sp2;
INSERT INTO products (name, price) VALUES ('Invalid Product', -50.00);
ROLLBACK TO SAVEPOINT sp2;
INSERT INTO products (name, price) VALUES ('Keyboard', 79.99);
COMMIT;

-- Explicit transactions for multiple operations
BEGIN;
INSERT INTO audit_log (action, timestamp) VALUES ('user_creation', NOW());
INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');
INSERT INTO user_preferences (user_id, theme) VALUES (currval('users_id_seq'), 'dark');
COMMIT;
